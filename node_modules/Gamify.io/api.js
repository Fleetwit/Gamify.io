var _ 					= require('underscore');
var file 				= require('./file.js').main;
var stack 				= require('./stack.js').main;

function api(Gamify) {
	this.Gamify = Gamify;
}
api.prototype.init = function(callback) {
	var scope 		= this;
	this.endpoints 	= {};
	this.outputs 	= {};
	
	var scanStack	= new stack();
	
	// List the endpoints map the methods
	scanStack.add(function(params, onProcessed) {
		file.listFiles("./api/endpoints","js", function(endpoints) {
			var i;
			var m;
			for (i=0;i<endpoints.length;i++) {
				var includepath				= endpoints[i].substr(0,endpoints[i].length-3);
				var	parts					= includepath.split("/");
				var urlpath					= parts[parts.length-1];
				var apiClass 				= require('../../'+includepath).api;
				(new apiClass()).init(scope.Gamify, function(methods) {
					scope.endpoints[urlpath] 	= {};
					console.log("**********************************");
					console.log("*****       APIs found       *****");
					console.log("++ "+urlpath);
					for (m in methods) {
						console.log("-- "+m);
						scope.endpoints[urlpath][m] = methods[m];
					}
					onProcessed();
				});
			}
		});
	},{});
	
	// List the output methods
	scanStack.add(function(params, onProcessed) {
		file.listFiles("./api/output","js", function(outputs) {
			var i;
			var m;
			console.log("**********************************");
			console.log("***** Output formaters found *****");
			for (i=0;i<outputs.length;i++) {
				var includepath				= outputs[i].substr(0,outputs[i].length-3);
				var	parts					= includepath.split("/");
				var urlpath					= parts[parts.length-1];
				var method 					= require('../../'+includepath).output;
				scope.outputs[urlpath]		= method;
				console.log("-- "+urlpath);
			}
			console.log("");
			onProcessed();
		});
	},{});
	
	
	// List the hooks
	scanStack.add(function(params, onProcessed) {
		file.listFiles("./api/hooks","js", function(outputs) {
			var i;
			var m;
			for (i=0;i<outputs.length;i++) {
				var includepath				= outputs[i].substr(0,outputs[i].length-3);
				// Simply execute the hooks.
				var incl					= require('../../'+includepath).hooks;
				incl(scope.Gamify);
			}
			onProcessed();
		});
	},{});
	
	// Process the stack, async
	scanStack.process(callback, true);
}
api.prototype.execute = function(endpoint, method, data, callback, format, req, res) {
	
	var scope 	= this;
	var error	= false;
	var response;
	
	// Default output format
	if (!format) {
		format = 'json';
	}
	
	console.log("execute()",endpoint, method, data, format);
	
	if (!this.endpoints[endpoint]) {
		console.log("No such endpoint: ",endpoint);
		// Create an error response
		response 	= this.errorResponse("No such endpoint.");
		error		= true;
	}
	if (!this.endpoints[endpoint][method]) {
		console.log("No such method: ",endpoint+'.'+method);
		// Create an error response
		response 	= this.errorResponse("No such method: ",endpoint+'.'+method);
		error		= true;
	}
	
	if (!error) {
		this.endpoints[endpoint][method](data, req, res, function(response) {
			
			// Do we have hooks?
			scope.Gamify.hook.trigger(endpoint, method, response, function(modifiedResponse) {
				if (res) {
					scope.outputs[format](modifiedResponse, res, data);
				}
				if (callback) {
					callback(modifiedResponse);
				}
			});
		});
	}
	
}
api.prototype.require = function(params, required) {
	var missing = [];
	var i;
	for (i in required) {
		if (!params[required[i]] && params[required[i]] !== false) {
			missing.push(required[i]);
		}
	}
	if (missing.length > 0) {
		return this.errorResponse('Missing parameters: '+missing.join(', '));
	} else {
		return true;
	}
}
api.prototype.fixTypes = function(params, types) {
	var i;
	for (i in params) {
		if (types[i]) {
			switch (types[i]) {
				case "object":
					if (typeof params[i] != 'object') {
						try {
							params[i] = JSON.parse(params[i]);
						} catch(e) {
							
						}
					}
				break;
				case "md5":
					params[i] = this.Gamify.crypto.md5(params[i].toString());
				break;
			}
		}
	}
	return params;
}
api.prototype.errorResponse = function(message, errorNumber) {
	if (!errorNumber) {
		var errorNumber = 0;
	}
	
	return {
		error:	{
			number:		errorNumber,
			message:	message
		}
	};
}

exports.main = api;